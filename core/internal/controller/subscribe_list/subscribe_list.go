// =================================================================================
// This is auto-generated by GoFrame CLI tool only once. Fill this file as you wish.
// =================================================================================

package subscribe_list

import (
	mail_v1 "billionmail-core/api/mail_boxes/v1"
	"billionmail-core/internal/model/entity"
	"billionmail-core/internal/service/batch_mail"
	"billionmail-core/internal/service/domains"
	"billionmail-core/internal/service/mail_boxes"
	"billionmail-core/internal/service/mail_service"
	"billionmail-core/internal/service/maillog_stat"
	"billionmail-core/internal/service/public"
	"context"
	"database/sql"
	"fmt"
	"github.com/gogf/gf/util/grand"
	"github.com/gogf/gf/v2/errors/gerror"
	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/os/gfile"
	"os"
	"path/filepath"
	"strings"
)

//// 联系人结构体
//type Contact struct {
//	Id     int
//	Email  string
//	Status int
//	// ...其他字段
//}

// 订阅组结构体
type Group struct {
	Id            int
	Name          string
	Token         string
	DoubleOptin   int
	WelcomeMailId int
	ConfirmMailId int
	SuccessUrl    string
	ConfirmUrl    string
	AlreadyUrl    string
	// ...其他字段
}

// 查找组
func getGroupByToken(token string) (*entity.ContactGroup, error) {
	var group entity.ContactGroup
	err := g.DB().Model("bm_contact_groups").Where("token", token).Scan(&group)
	if err != nil && err == sql.ErrNoRows {
		err = nil
	}
	return &group, err
}

// 查找联系人
func getContactByEmailAndGroup(email string, groupId int) (*entity.Contact, error) {
	// 查询数据库 bm_contacts where email=? and group_id=?
	var contact entity.Contact
	err := g.DB().Model("bm_contacts").
		Where("group_id", groupId).
		Where("email", email).
		Scan(&contact)
	if err != nil && err == sql.ErrNoRows {
		err = nil
	}

	return &contact, err
}

// 添加/更新联系人
func addOrUpdateContact(email string, groupId int, attribs map[string]string, status int) error {

	// 处理旧数据 已经在联系人表 但不在当前组的 也不用确认
	count, err := g.DB().Model("bm_contacts").
		Where("email", email).
		Count()
	if err == nil && count > 0 {
		status = 1 // 已经存在联系人，直接设置为已确认状态
	}

	// 如果已存在则更新，否则插入
	var contact entity.Contact
	err = g.DB().Model("bm_contacts").
		Where("email", email).
		Where("group_id", groupId).
		Scan(&contact)

	if err != nil && err == sql.ErrNoRows {
		err = nil
	}

	if err != nil {
		return err
	}

	if g.IsEmpty(contact) {
		// 插入新联系人
		contact = entity.Contact{
			Email:   email,
			GroupId: groupId,
			Status:  status,
			Attribs: attribs,
		}
		_, err = g.DB().Model("bm_contacts").Data(contact).OmitEmpty().Insert()
		if err != nil {
			return err
		}
	}

	// 更新现有联系人
	contact.Status = status
	contact.Attribs = attribs
	_, err = g.DB().Model("bm_contacts").Data(contact).Where("id", contact.Id).Update()
	if err != nil {
		return err
	}

	return nil
}

// 更新联系人状态 确认(0,1)  订阅1
func updateContactStatus(email string, groupId int, status int) error {
	// update bm_contacts set status=? where email=? and group_id=?

	_, err := g.DB().Model("bm_contacts").
		Data(g.Map{"status": status, "active": 1}).
		Where("email", email).
		Where("group_id", groupId).
		Update()

	return err
}

func readTemplateFiles(baseFilename string) (htmlContent string, txtContent string, err error) {
	hostwork := public.HostWorkDir

	// 构造两个文件路径（自动处理不同操作系统分隔符）
	htmlPath := filepath.Join(hostwork, "core", "data", baseFilename+".html")
	txtPath := filepath.Join(hostwork, "core", "data", baseFilename+".txt")

	// 安全检查（防止目录遍历）
	cleanDir := filepath.Clean(filepath.Join(hostwork, "core", "data"))
	if !strings.HasPrefix(filepath.Clean(htmlPath), cleanDir) ||
		!strings.HasPrefix(filepath.Clean(txtPath), cleanDir) {
		return "", "", fmt.Errorf("非法路径访问: %s", baseFilename)
	}

	// 读取HTML文件
	htmlBytes, err := os.ReadFile(htmlPath)
	if err != nil {
		return "", "", fmt.Errorf("读取HTML模板失败: %w", err)
	}

	// 读取TXT文件（允许不存在）
	txtBytes, err := os.ReadFile(txtPath)
	if err != nil {
		if !os.IsNotExist(err) {
			g.Log().Warningf(context.Background(),
				"读取TXT模板失败: %v, 路径: %s", err, txtPath)
		}
		txtBytes = []byte("") // 不存在时返回空内容
	}

	return string(htmlBytes), string(txtBytes), nil
}

func GetDefaultTemplate(emailType int) (html string, txt string) {
	var (
		defaultHtml string
		defaultTxt  string
		basePath    string
	)

	switch emailType {
	case 1: // 欢迎邮件
		basePath = "default_welcome_email/welcome_email"
		defaultHtml = "<p>Welcome to subscribe!</p>"
		defaultTxt = ""
	case 2: // 确认邮件
		basePath = "default_confirm_email/confirm_email"
		defaultHtml = "<p>Please confirm your subscription.</p>"
		defaultTxt = ""
	default:
		return "<p>Welcome to subscribe!</p>", ""
	}

	htmlContent, txtContent, err := readTemplateFiles(basePath)
	if err != nil {
		g.Log().Errorf(context.Background(),
			"获取模板失败，使用默认内容。错误: %v, 路径: %s",
			err, basePath)
		return defaultHtml, defaultTxt
	}

	return htmlContent, txtContent
}

// 发送邮件
func sendMail(ctx context.Context, emailHtml, email, subject, confirmUrl string) error {
	// 1. 获取模板
	if emailHtml == "" {
		return gerror.New(public.LangCtx(ctx, "邮件模板ID不能为空"))
	}

	// 如果存在{{ ConfirmURL . }}变量，则替换为确认链接
	if strings.Contains(emailHtml, "{{ ConfirmURL . }}") {
		if confirmUrl == "" {
			return gerror.New(public.LangCtx(ctx, "确认邮件需要提供确认链接"))
		}
		emailHtml = strings.ReplaceAll(emailHtml, "{{ ConfirmURL . }}", confirmUrl)
	}

	// 2. 获取联系人（用于变量替换）
	var contact entity.Contact
	_ = g.DB().Model("bm_contacts").Where("email", email).Scan(&contact)

	// 3. 退订链接处理
	content := emailHtml
	//if !strings.Contains(content, "{{ UnsubscribeURL . }}") {
	//	content = public.AddUnsubscribeButton(content)
	//}

	//// 4. 生成退订jwt和链接
	//jwtToken, _ := batch_mail.GenerateUnsubscribeJWT(email, templateId, 0)
	//domain := domains.GetBaseURL()
	//unsubscribeURL := fmt.Sprintf("%s/api/unsubscribe", domain)
	//groupURL := fmt.Sprintf("%s/api/unsubscribe/user_group", domain)
	//unsubscribeJumpURL := fmt.Sprintf("%s/unsubscribe.html?jwt=%s&email=%s&url_type=%s&url_unsubscribe=%s",
	//	domain, jwtToken, email, groupURL, unsubscribeURL)

	// 5. 渲染内容和主题
	engine := batch_mail.GetTemplateEngine()

	personalizedContent, err := engine.RenderEmailTemplate(ctx, content, &contact, nil, "")
	if err != nil {
		return gerror.New(public.LangCtx(ctx, "渲染邮件内容失败"))
	}
	g.Log().Errorf(context.Background(), "主题:22 %v", subject)
	personalizedSubject, err := engine.RenderEmailTemplate(ctx, subject, &contact, nil, "")
	if err != nil {
		return gerror.New(public.LangCtx(ctx, "渲染邮件主题失败"))
	}
	g.Log().Errorf(context.Background(), "主题: 33%v", personalizedSubject)
	//address := "noreply@lotkfc.cn"
	DefaultDomain, err := getDefaultDomain()
	if err != nil {
		return gerror.New(public.LangCtx(ctx, "获取默认发件域名失败: {}", err))
	}
	address, err := createNoreplyEmail(DefaultDomain)
	if err != nil {
		return gerror.New(public.LangCtx(ctx, "查找noreply邮箱失败: {}", err))
	}

	// 6. 创建发件人
	sender, err := mail_service.NewEmailSenderWithLocal(address)
	if err != nil {
		return gerror.New(public.LangCtx(ctx, "创建发件人失败"))
	}
	defer sender.Close()
	messageId := sender.GenerateMessageID()

	//Tracking emails
	baseURL := domains.GetBaseURLBySender(address)
	mail_tracker := maillog_stat.NewMailTracker(personalizedContent, -1, messageId, email, baseURL)
	mail_tracker.TrackLinks()
	mail_tracker.AppendTrackingPixel()
	renderedContent := mail_tracker.GetHTML()

	// 7. 创建消息
	message := mail_service.NewMessage(personalizedSubject, renderedContent)
	message.SetMessageID(messageId)
	message.SetRealName("noreply")

	// 8. 发送邮件
	err = sender.Send(message, []string{email})
	if err != nil {
		return gerror.New(public.LangCtx(ctx, "发送邮件失败: {}", err))
	}

	return nil
}

// 生成token
func generateConfirmToken(email, groupToken string) string {
	token, err := batch_mail.GenerateSubscribeConfirmJWT(email, groupToken)
	if err != nil {
		g.Log().Errorf(context.Background(), "生成订阅确认token失败: %v", err)
		return ""
	}
	return token
}

// 取token中的email  groupToken
func getEmailFromToken(token string) (string, string, error) {
	claims, err := batch_mail.ParseSubscribeConfirmJWT(token)
	if err != nil {
		return "", "", gerror.New("解析订阅确认token失败: " + err.Error())
	}
	return claims.Email, claims.GroupToken, nil
}

// 构建确认链接
func buildConfirmUrl(token string) string {
	hostUrl := public.GethostUrl()
	return fmt.Sprintf("%s/api/subscribe/confirm?token=%s", hostUrl, token)
}

// 查询发件邮箱是否存	创建
func createNoreplyEmail(domain string) (string, error) {
	noreplyEmail := "noreply@" + domain
	count, err := g.DB().Model("mailbox").Where("username", noreplyEmail).Count()
	if err != nil {
		return "", gerror.New("查询邮箱失败")
	}
	if count == 0 {
		ctx := context.Background()
		_ = mail_boxes.Add(ctx, &mail_v1.Mailbox{
			Username:  noreplyEmail,
			Password:  grand.S(16),
			FullName:  "noreply",
			IsAdmin:   0,
			Quota:     5242880,
			LocalPart: "noreply",
			Domain:    domain,
			Active:    1,
		})
	}
	return noreplyEmail, nil
}

// 获取默认发件域名
func getDefaultDomain() (string, error) {
	ctx := context.Background()

	configuredDomain, err := g.DB().Model("bm_options").
		Where("name", "default_sender_domain").
		Value("value")

	if err == nil && configuredDomain != nil {
		return configuredDomain.String(), nil
	}

	// 2. 获取最早创建的活跃域名

	oldestDomain, err := g.DB().Model("domain").
		Order("create_time", "asc").
		Where("active", 1).
		Limit(1).
		Value("domain")
	if err != nil || oldestDomain == nil {

		return "", gerror.New("没有可用的活跃域名，请先添加域名")
	}

	// 3. 保存到配置表
	_, err = g.DB().Model("bm_options").
		Data(g.Map{
			"name":  "default_sender_domain",
			"value": oldestDomain.String(),
		}).
		OnConflict("name").
		Save()

	if err != nil {
		g.Log().Errorf(ctx, "保存默认域名失败: %v", err)
		return "", gerror.Wrap(err, "保存默认发件域名配置失败")
	}

	return oldestDomain.String(), nil
}

// 获取订阅表单代码
func GetSubscribeFormCode(groupToken string) string {
	// D:\Billion-Mail\core\public\html
	hostwork := public.HostWorkDir
	filePath := filepath.Join(hostwork, "core", "public", "html", "subscribe_form_code.html")
	content := gfile.GetContents(filePath)

	if !strings.Contains(content, "{{ SubmitURL . }}") {
		return ""
	}
	// 链接对应页面
	var submitUrl string
	hostUrl := public.GethostUrl()
	submitUrl = hostUrl + "/api/subscribe/submit?token=" + groupToken

	newContent := strings.ReplaceAll(content, "{{ SubmitURL . }}", submitUrl)

	return newContent

}
