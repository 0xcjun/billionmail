// =================================================================================
// This is auto-generated by GoFrame CLI tool only once. Fill this file as you wish.
// =================================================================================

package relay

import (
	domainsV1 "billionmail-core/api/domains/v1"
	"billionmail-core/internal/model/entity"
	docker "billionmail-core/internal/service/dockerapi"
	"billionmail-core/internal/service/domains"
	"billionmail-core/internal/service/public"
	"context"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"github.com/gogf/gf/v2/crypto/gaes"
	"github.com/gogf/gf/v2/errors/gerror"
	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/os/gfile"
	"path"
	"strings"
)

const (
	// Postfix-related configuration paths
	postfixConfigDir     = "/opt/Billion-Mail/conf/postfix"
	senderRelayFile      = "/conf/sender_relay"
	saslPasswdFile       = "/conf/sasl_passwd"
	mainCfFile           = "main.cf"
	postfixContainerName = "billionmail-postfix-billionmail-1"
)

func GetRelayEncryptionKey() (string, error) {
	// 1. Retrieve key from the database
	val, err := g.DB().Model("bm_options").
		Where("name", "relay_encryption_key").
		Value("value")

	if val != nil && val.String() != "" {
		return val.String(), nil
	}

	// 2. Generate key
	newSecret, err := generateRandomKey(16)
	if err != nil {
		return "", gerror.Wrap(err, "Failed to generate new relay encryption key")
	}

	// 3. Save the new key to the database
	_, err = g.DB().Model("bm_options").
		Data(g.Map{
			"name":  "relay_encryption_key",
			"value": newSecret,
		}).
		Insert()
	if err != nil {
		// If insert fails, attempt to retrieve the key again
		val, err = g.DB().Model("bm_options").
			Where("name", "relay_encryption_key").
			Value("value")

		if val != nil && val.String() != "" {
			return val.String(), nil
		}
		return "", gerror.New("Failed to insert new key and retrieve key again")
	}

	return newSecret, nil
}

// generateRandomKey generates a random key of the specified length.
func generateRandomKey(length int) (string, error) {
	key := make([]byte, length)
	_, err := rand.Read(key)
	if err != nil {
		return "", err
	}

	return hex.EncodeToString(key), nil
}

func EncryptPassword(ctx context.Context, plainText string) (string, error) {
	if plainText == "" {
		return "", gerror.New(public.LangCtx(ctx, "Password cannot be empty"))
	}
	relayEncryptionKey, err := GetRelayEncryptionKey()
	if err != nil {
		return "", gerror.Wrap(err, public.LangCtx(ctx, "Failed to retrieve encryption key"))
	}

	keyBytes, err := hex.DecodeString(relayEncryptionKey)
	if err != nil {
		return "", gerror.Wrap(err, public.LangCtx(ctx, "Failed to parse encryption key"))
	}

	if len(keyBytes) < 16 {
		return "", gerror.New(public.LangCtx(ctx, "Encryption key length is insufficient"))
	}
	keyBytes = keyBytes[:16]

	encrypted, err := gaes.Encrypt([]byte(plainText), keyBytes)
	if err != nil {
		g.Log().Errorf(ctx, "Password encryption failed: %v", err)
		return "", gerror.Wrap(err, public.LangCtx(ctx, "Password encryption failed"))
	}

	return hex.EncodeToString(encrypted), nil
}

func DecryptPassword(ctx context.Context, encryptedHex string) (string, error) {
	if encryptedHex == "" {
		return "", nil
	}

	encryptedBytes, err := hex.DecodeString(encryptedHex)
	if err != nil {
		g.Log().Errorf(ctx, "Decryption failed, invalid hex format: %v", err)
		return "", gerror.Wrap(err, public.LangCtx(ctx, "Password format is incorrect"))
	}

	relayEncryptionKey, err := GetRelayEncryptionKey()
	if err != nil {
		return "", gerror.Wrap(err, public.LangCtx(ctx, "Failed to retrieve encryption key"))
	}

	keyBytes, err := hex.DecodeString(relayEncryptionKey)
	if err != nil {
		return "", gerror.Wrap(err, public.LangCtx(ctx, "Failed to parse encryption key"))
	}

	if len(keyBytes) < 16 {
		return "", gerror.New(public.LangCtx(ctx, "Encryption key length is insufficient"))
	}
	keyBytes = keyBytes[:16]

	decrypted, err := gaes.Decrypt(encryptedBytes, keyBytes)
	if err != nil {
		g.Log().Errorf(ctx, "Password decryption failed: %v", err)
		return "", gerror.Wrap(err, public.LangCtx(ctx, "Password decryption failed"))
	}

	return string(decrypted), nil
}

func buildCacheKey(domain, recordType string) string {
	return fmt.Sprintf("DOMAIN_DNS_RECORDS_:%s:_%s", domain, recordType)
}

// GenerateSPFRecord generates SPF record hints based on IP and host.
func GenerateSPFRecord(ip string, host string, domain string) string {
	// Retrieve the current SPF record for the domain
	var existingValue string
	var newSpfParts []string

	// Fetch SPF record from cache or domains service
	spfRecord := public.GetCache(buildCacheKey(domain, "SPF"))

	if spfRecord != nil {
		if v, ok := spfRecord.(domainsV1.DNSRecord); ok {
			existingValue = v.Value
		}
	}

	// If cache is empty, attempt to fetch from domains service
	if existingValue == "" {
		record, _ := domains.GetSPFRecord(domain, false)
		existingValue = record.Value
	}

	// Create a basic record if none exists
	if existingValue == "" {
		existingValue = "v=spf1 +a +mx"
	}

	// Analyze the existing record to avoid duplications
	parts := strings.Split(existingValue, " ")
	existingParts := make(map[string]bool)
	var allMechanism string

	for _, part := range parts {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}
		existingParts[part] = true
		if strings.HasSuffix(part, "all") {
			allMechanism = part
			continue
		}
		newSpfParts = append(newSpfParts, part)
	}

	// Add IP if provided and not duplicated
	if ip != "" {
		var ipPart string
		if strings.Contains(ip, ":") {
			ipPart = fmt.Sprintf("+ip6:%s", ip)
		} else {
			ipPart = fmt.Sprintf("+ip4:%s", ip)
		}
		if !existingParts[ipPart] {
			newSpfParts = append(newSpfParts, ipPart)
		}
	}

	// Add host if provided and not duplicated
	if host != "" {
		var hostPart string

		hostPart = fmt.Sprintf("include:%s", host)

		if !existingParts[hostPart] {
			newSpfParts = append(newSpfParts, hostPart)
		}
	}

	if allMechanism != "" {
		newSpfParts = append(newSpfParts, allMechanism)
	} else {
		newSpfParts = append(newSpfParts, "~all")
	}

	return strings.Join(newSpfParts, " ")
}

// SyncRelayConfigsToPostfix
func SyncRelayConfigsToPostfix(ctx context.Context) error {
	// 1. Ensure the configuration directory exists
	senderRelayPath := path.Join(postfixConfigDir, senderRelayFile)
	saslPasswdPath := path.Join(postfixConfigDir, saslPasswdFile)
	mainCfPath := path.Join(postfixConfigDir, mainCfFile)

	if !gfile.Exists(postfixConfigDir) {
		return gerror.Newf(public.LangCtx(ctx, "Postfix configuration directory does not exist : %s", postfixConfigDir))
	}
	// 2. Query all enabled relay configurations
	var activeConfigs []*entity.BmRelay
	err := g.DB().Model("bm_relay").Where("active", 1).Scan(&activeConfigs)
	if err != nil {
		return gerror.Wrap(err, public.LangCtx(ctx, "Failed to query relay configurations"))
	}
	// 3. Generate sender_relay file content
	var senderRelayContent strings.Builder
	var saslPasswdContent strings.Builder

	if len(activeConfigs) == 0 {
		senderRelayContent.WriteString("# No active relay configurations\n")
		saslPasswdContent.WriteString("# No active relay configurations\n")
	} else {
		for _, config := range activeConfigs {
			senderDomain := config.SenderDomain
			if !strings.HasPrefix(senderDomain, "@") {
				senderDomain = "@" + senderDomain
			}

			senderRelayContent.WriteString(fmt.Sprintf("%s [%s]:%s\n",
				senderDomain, config.RelayHost, config.RelayPort))
			// Process sasl_passwd content
			decryptedPass, err := DecryptPassword(ctx, config.AuthPassword)
			if err != nil {

				continue
			}

			saslPasswdContent.WriteString(fmt.Sprintf("[%s]:%s %s:%s\n",
				config.RelayHost, config.RelayPort, config.AuthUser, decryptedPass))
		}
	}
	// 4. Write configuration files
	if err := gfile.PutContents(senderRelayPath, senderRelayContent.String()); err != nil {
		return gerror.Newf("Failed to write sender_relay file: %v", err)
	}

	if err := gfile.PutContents(saslPasswdPath, saslPasswdContent.String()); err != nil {
		return gerror.Newf("Failed to write sasl_passwd file: %v", err)
	}
	// 5. Decide whether to enable relay functionality based on active configurations
	if err := ensurePostfixRelayConfig(mainCfPath, len(activeConfigs) > 0); err != nil {
		return err
	}
	// 6. Execute Postfix commands
	dk, dockerErr := docker.NewDockerAPI()
	if dockerErr != nil {
		g.Log().Error(ctx, "Failed to connect to Docker API:", dockerErr)
		return gerror.Wrap(dockerErr, public.LangCtx(ctx, "Failed to connect to Docker service"))
	}
	defer dk.Close()

	cmdsToRun := [][]string{
		{"postmap", "/etc/postfix/conf/sender_relay"},
		{"postmap", "/etc/postfix/conf/sasl_passwd"},
		{"postfix", "reload"},
	}

	for _, cmd := range cmdsToRun {
		cmdStr := strings.Join(cmd, " ")
		g.Log().Infof(ctx, "Executing command in container %s: %s", postfixContainerName, cmdStr)
		result, err := dk.ExecCommandByName(ctx, postfixContainerName, cmd, "root")

		if err != nil {
			g.Log().Errorf(ctx, "Failed to execute command: %v, Command: %s", err, cmdStr)
			return gerror.Newf("Failed to execute command: %v, Command: %s", err, cmdStr)
		}

		if result == nil {
			g.Log().Errorf(ctx, "Command execution result is empty: %s", cmdStr)
			return gerror.Newf("Command execution result is empty: %s", cmdStr)
		}

		if result.ExitCode != 0 {
			g.Log().Errorf(ctx, "Command execution returned non-zero status: %d, Output: %s, Command: %s",
				result.ExitCode, result.Output, cmdStr)
			return gerror.Newf("Command execution failed, Exit code: %d, Output: %s, Command: %s",
				result.ExitCode, result.Output, cmdStr)
		}
		g.Log().Infof(ctx, "Command executed successfully: %s, Output: %s", cmdStr, result.Output)
	}
	g.Log().Info(ctx, "Relay configurations synchronized to Postfix successfully")
	return nil
}

// ensurePostfixRelayConfig Ensures that the Postfix main.cf configuration file contains necessary relay configurations
func ensurePostfixRelayConfig(mainCfPath string, enableRelay bool) error {
	content := gfile.GetContents(mainCfPath)
	// Define the start and end markers for the configuration block
	beginMarker := "# BEGIN RELAY SERVICE CONFIGURATION - DO NOT EDIT THIS MARKER"
	endMarker := "# END RELAY SERVICE CONFIGURATION - DO NOT EDIT THIS MARKER"

	// Construct the complete configuration block
	configBlock := fmt.Sprintf(`%s
smtp_sasl_auth_enable = yes
smtp_sasl_security_options = noanonymous
sender_dependent_relayhost_maps = hash:/etc/postfix/conf/sender_relay
smtp_sasl_password_maps = hash:/etc/postfix/conf/sasl_passwd
%s`, beginMarker, endMarker)

	// Find the existing configuration block
	beginIndex := strings.Index(content, beginMarker)
	endIndex := strings.Index(content, endMarker)

	// Check if the configuration block exists
	hasConfigBlock := beginIndex != -1 && endIndex != -1 && beginIndex < endIndex

	// Decide the operation based on whether relay is enabled and if the configuration block exists
	modified := false

	if enableRelay {
		if hasConfigBlock {
			g.Log().Debug(nil, "Relay configuration block already exists, no modification needed")
		} else {
			// Need to add the configuration block
			if strings.HasSuffix(content, "\n") {
				content = content + configBlock + "\n"
			} else {
				content = content + "\n" + configBlock + "\n"
			}
			modified = true
		}
	} else {
		if hasConfigBlock {
			// Need to remove the configuration block
			blockStart := beginIndex
			blockEnd := endIndex + len(endMarker)

			if blockEnd < len(content) && content[blockEnd] == '\n' {
				blockEnd++
			}

			newContent := content[:blockStart]
			if blockEnd < len(content) {
				newContent += content[blockEnd:]
			}
			content = newContent
			modified = true
		}
	}
	// If there are modifications, write to the file
	if modified {
		if err := gfile.PutContents(mainCfPath, content); err != nil {
			return gerror.Newf("Failed to write main.cf file: %v", err)
		}
	}

	return nil
}
